# Pentest---DC-1
A comprehensive walkthrough detailing the penetration testing process conducted on the DC-1 machine from VulnHub. Includes step-by-step instructions, techniques, and insights into identifying and exploiting vulnerabilities for educational purposes.
**Target**
Hack the machine (DC-1) and get the root privilege.
https://www.vulnhub.com/entry/dc-1,292/ : Here, you will find more information about the vulnerable machine we are using.

**Installation**
Download the virtual machine, extract the files, and import them into VirtualBox. Connect it to the NAT Network and start it up. Additionally, I booted up my Kali Linux for the penetration test. I initiated the initial scanning procedures, and you can see the screenshots of the scans below.

<img width="407" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/83db897f-f613-4c21-a3f7-9f9cd3a75663">

Did a nmap 10.0.2.8 -p- -sV -A --script=vuln

**Port: 22/tcp    open  ssh     Service:OpenSSH 6.0p1 Debian 4+deb7u7 (protocol 2.0)**
More info on the vulnerability:

<img width="629" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/d9b32664-6f14-44cd-ac06-444de6451f88">

Command execution/remote code execution(RCE) is a security vulnerability that allows an attacker to execute arbitrary commands or code on a target system. 
The screenshot above indicates that the vulnerability is linked to the SFTP service. However, in our situation, the service running on the port 22 is SSH. Therefore, we cannot exploit this vulnerability to gain unauthorized access to the system.

**80/tcp    open  http    Apache httpd 2.2.22 ((Debian))**
http-generator: Drupal 7 (http://drupal.org)
http-server-header: Apache/2.2.22 (Debian)
http-title: Welcome to Drupal Site | Drupal Site

<img width="650" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/2c79c339-a77c-495a-8d06-70df2d73a4e7">

On port 80, the server is running the HTTP service. The "Type" mentioned in the screenshot above is "web apps", indicating that it provides the HTTP service. If we exploit this vulnerability, we could launch an attack through the website.

This vulnerability is related to the HTTP method OPTIONS Memory Leak, which is used in communication between web browsers and servers. By sending specially crafted requests using the OPTIONS Memory Leak method to the vulnerable Apache server, we can determine which methods or functionalities are available on the server. This could potentially allow us to manipulate or delete existing content on the server.

However, it's important to note that this vulnerability has been patched. Additionally, if we attempt to use the OPTIONS Memory Leak method, it will likely be sanitized before reaching the server. As a result, we can only consider it a minor vulnerability.

**Port:111/tcp   open  rpcbind 2-4 (RPC #100000)
Port:41827/tcp open  status  1 (RPC #100024)**

OS: Linux; CPE: cpe:/o:linux:linux_kernel
Port: 41827/tcp
Service: rpcbind (RPC #100024)
Explanation: In this scan, the nmap output detected service and identified the service running on that port as rpcbind. It further provides the RPC program number (#100024).
What is RPC Bind Service (rpcbind): It is a remote procedure call (RPC) service. RPC is a protocol that allows programs on different machines to communicate with each other.
Rpcbind acts as a registry for RPC programs, helping client programs find the server programs they need to communicate with.
Port Usage: Typically, rpcbind listens on a well-known port, which by default is UDP port 111.
The fact that this service is found on a non-standard port (41827/tcp) suggests it might be a custom configuration or an attempt to obfuscate the service.
Based on this information, we've determined that there are no vulnerabilities associated with these two ports in this scenario. 
Scan results:

<img width="461" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/06254f75-65e0-4d52-9604-326c3085295a">

Since there's an HTTP service up and running on the machine, let's go ahead and take a look at the website. 

<img width="381" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/a7a80589-931a-4f51-b69b-a15018638515">

We have a website called 'Drupal Site'.
Now, open the 'Wappalyzer' browser extension.
You can use this extension to know about the technologies, versions, types of services, and content used to build the site. Take a look at the screenshot below. 
Note:This information is not accessible through a regular Nmap scan.

<img width="269" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/fda8e812-eec1-4516-be3b-8299582f0f03">

**Here CMS (Content management system) is Drupal 7, we can also see the programming language used. Server, OS, Script Libraries etc.**

A Content Management System (CMS) is a software application that simplifies the creation and management of website content(Like usernames, data, sessions etc).  Imagine it as a user-friendly control panel for your website, allowing you to make edits and updates without needing to write complex code.
Wordpress is another example for CMS.

Basically, HTTP operates on port 80, and it's managed by Apache. Within Apache, the Content Management System (CMS) installed is Drupal 7. So, we need to investigate if Drupal 7 has any vulnerabilities. If it does, we can gain direct access to Port 80.
Let's examine if Drupal 7 has any vulnerabilities, while simultaneously attempting to brute force the directory. By 'directory,' we mean the web application's links that provide direct access to specific pages. For example,
<img width="479" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/ff3c7abd-1e1b-4b08-8720-ea7ca41836c4">
In the URL, we notice "/#inbox." If we want to go straight to the sent folder in Gmail, we can simply edit the link and replace "/#inbox" with "/#sent" and press enter. This will directly take us to the sent folder in Gmail. So, these terms like 'Inbox' and 'sent' represent different directories within Gmail. Similarly, we're now going to discover directories on this website (Drupal Site) using Directory Brute force. 

**So to brute force Directory we can use the tool ‘dirb’**
The command is:
**dirb http://<target ip> <enter>**

<img width="229" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/5a004133-6aef-4917-bf5a-5e99d8d37843">

In the screenshot provided, we see the IP address 10.0.2.8 with the subnet mask /0. Here, the '0' indicates an area with the status code 200, suggesting that it might be accessible. However, if we encounter the status code 403, it indicates a client-side error occurring in the 'admin' area, implying that we do not have access to it.

Since 'dirb' is slow and may take a while to retrieve directory details, we're switching to another tool called 'gobuster'. Dirbuster is another tool used for directory brute-forcing.
Gobuster, built with the Go language like Python, is much faster. You can find more information about Gobuster and its uses at https://www.kali.org/tools/gobuster/. Additionally, Gobuster can be employed to brute-force subdomains (e.g., www). 

**Installation of gobuster**
Command: gobuster dir -u  http://10.0.2.8 -w /usr/share/dirb/wordlists/common.txt <enter>
If you execute the command above and Gobuster isn't installed on your system yet, you'll see a prompt asking if you want to continue with the installation. Simply type "Y" to proceed. Once the installation is complete, run the command again and press "Enter."
**Breakdown of the command: **
gobuster dir is mandatory
-u to specify the url, ie,  http://10.0.2.8
-w to add the word list path. 
Here we are using the wordlist path of ‘dirb’
Ie,  /usr/share/dirb/wordlists/common.txt 
In this common.txt is the word list file
See the SS below for the path to the ‘dirb’ word lists. 

<img width="235" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/5db27e0a-796e-410b-8735-7b2002881ee2">

Executing the Gobuster command now:

<img width="314" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/9ac46682-858c-4eaf-a59a-886eb9de5194">
<img width="329" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/f0b869be-f9d6-4b38-9749-247999d150b9">
We can see the directories (/0, /sites, /user etc)present in the target. 

Also, we can see the Status 200 is in green color, 301 is in Blue and 403 is in Orange.
Explanations for theses status codes:
200 - OK: It indicates that the web server successfully retrieved a response for the directory path Gobuster tried to access. This suggests that the directory might exist and could potentially contain website content.

403 - Forbidden: This status code implies that the web server understood the request (to access a specific directory) but deliberately denied access.  
301 - Moved Permanently: This code indicates that the requested directory has been permanently moved (redirected) to a new location.  

Now, we need to see where these directories lead us when used in the URL.
Refer to the screenshot below for an example: I am attempting to access the directory /0.

<img width="389" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/1e63e879-f1e4-428c-93d6-a18860cdf411">

It is taking us here.
Since we've identified that the website's CMS is Drupal 7 using Wappalyzer, let's investigate if it has any vulnerabilities. We'll search for vulnerabilities on Google, Exploit.db, Searchsploit, etc. Additionally, we'll inspect the source page to see if we can find the CMS version.

After checking all of the above, I'm now examining Metasploit. I conducted a search for Drupal, and below are the results I obtained.

<img width="470" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/702fedad-6494-49cf-887a-e886a3ed4662">

I am selecting the option 1 from here
Reasons: It indicates that it's related to a web app. Its rank is excellent, and the description mentions "Forms API property injection." So, let's execute it and check if we can obtain a shell. I chose option 1 from the provided options, entered the RHOSTS. There's no need to specify the payload separately since it's already included with the exploit. Also, we don't need to alter the TARGETURI because we found out from Wappalyzer that the website is built on a CMS. However, in certain situations, if the homepage of the website uses different technologies and the CMS is located in other directories of the site, then we would need to specify the path to the CMS in the TARGETURI before launching the exploit. 
Now, let's proceed to RUN it.

<img width="458" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/9a47298b-35d7-4dc6-95bb-7b91c761dde0">

We've successfully gained access to the target machine. When performing the 'PWD' command, we can see that we're currently located in the '/var/www' directory. This directory is typically where Apache web server files are stored on Linux systems. Being in this directory indicates that we've successfully breached and gained access to the Apache path on the target system.

<img width="110" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/2ff946c1-1519-435e-98cf-7badbb9b2b3b">

Here, we got the Meterpreeter shell.
What is Meterpreeter?
In the Meterpreter shell, standard Linux commands may not work as expected. Meterpreter provides a post-exploitation environment, allowing us to interact with compromised systems, whether they are running Windows or Linux, via a command-line interface (CLI). While we can execute Meterpreter-specific commands in the shell, they will run directly on the target machine and provide us with responses.
Some features of Meterpreter include capturing screenshots of the target machine, extracting password hashes, recording the screen, playing audio files on the target system, and capturing keystrokes. By using the 'shell' command followed by pressing the 'Enter' key, we can access a native shell of the target machine from within Meterpreter. From there, we must use commands appropriate for the target system's operating system; for example, if we compromised a Windows machine, we would use Windows CLI commands. To exit the shell, we can use the 'Ctrl+C' command followed by pressing 'Enter'.
We can also minimize the Meterpreter shell by pressing Ctrl+Z, then typing 'y' followed by Enter. This will minimize the Meterpreter shell, allowing us to search for other modules in Metasploit. See the screenshot below.

<img width="472" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/c512ad44-6fa1-4e73-af45-05d34e00c68c">

Perform: help <enter> to see what other commands will work in the Meterpreeter shell.  

See the SS below.

<img width="292" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/495ecb71-880f-4e14-9ec2-866f5f2abefa">

Now, let’s get back into the pentest.
We attacked a service (Drupal) and successfully breached the system, gaining access to a user domain (/var/www) owned by that service's user within the organization. This explains why, despite attacking a service, we ended up accessing a user domain.
We entered into the shell of the target machine using the SHELL command.

<img width="169" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/132933e1-fe1c-48c2-8258-eadb5a535019">

When entering whoami, we can see that we are the www-data user. 
The www-data user is a standard account often found on Unix-based operating systems like Linux. It's the user that web servers such as Apache or nginx usually operate under. This user is automatically created when we install Apache or nginx on any Linux machine, including our Kali system. While regular users cannot log in with this user ID, but we gained access to it through our attack on Apache.

<img width="287" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/0082e1da-7fd0-4fa7-b459-6753691e0e2d">

We've hacked into the system, so now we need to do privilege escalation to gain root access.
ls we could see a few directories.
<img width="179" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/24225f4e-c81f-4b46-8edd-85030a1ac0a2">

We tried to jump into the root folder, but the system is denying us. 
Let's examine the shell. It seems disorganized (the directories are showing as a long list), so to tidy it up and make it interactive, let's utilize the python spawn command. Follow the link below. This command helps in opening a new, interactive shell on the target machine. 
https://hidepatidar.medium.com/spawning-interactive-reverse-shell-7732686ea775
**python -c 'import pty; pty.spawn("/bin/sh")' **

<img width="289" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/111cca93-e02b-4bff-8a7a-0d0189d66c7b">

After using the spawn command, we now see a $ symbol and the folder list appears organized. However, we're still a regular user and need to perform privilege escalation. There are two types of privilege escalation. They are:
Horizontal privilege escalation occurs when an attacker gains access at the same permission level but under different user identities. 

Vertical privilege escalation, also known as a privilege elevation attack, involves an increase of privileges/privileged access beyond what a user, application, or other asset already has. This entails moving from a low level of privileged access to a higher level of privileged access.

<img width="299" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/3017d969-622c-46b0-b2a1-32e317a94489">

But in this case, we see only 1 user, ie, www-data.
So the Horizontal privilege escalation is not possible here.
Let’s try vertical privilege escalation here.

<img width="151" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/3dcf4ad8-8264-4c4e-988f-bc5472059d1e">

As in the last pentest, we tried the sudo -l command , but that is not working here.
Now we need to check if there are any SUID Bit binaries of root is available.
SUID binaries are executable files with a special permission setting that allows them to be run with the privileges of the file's owner, instead of the user who is actually executing the program.
In simple words, if other user execute a file, they will also get the same response and privilege at the time of file execution.
How this will help in the vertical privilege escalation?
We need to find the SUID Bit binaries of the root user. So if we run these files, we get the root privileges at the time of running the file.
There is a command to find out the SUID Bit binary of the root user. Follow the link below.
https://www.hackingarticles.in/linux-privilege-escalation-using-suid-binaries/

By using the following command, you can enumerate all binaries having SUID permissions:

**find / -perm -u=s -type f 2>/dev/null**
find/ denotes start from the top (root) of the file system and find every directory
-perm denotes search for the permissions that follow
-u=s denotes look for files that are owned by the root user
-type states the type of file we are looking for
f denotes a regular file, not the directories or special files

2>/dev/null = When checking, we get a lot of files of the root user, with this 2>/dev/null in the command, it means redirecting the files to the black hole/Bin in Linux if the www-data user does not have access to any of the root files, only show the accessible root user files. Below, you can see the explanation of 2>/dev/null. 
2 denotes to the second file descriptor of the process, i.e. (standard error)
> means redirection
/dev/null is a special filesystem object that throws away everything written into it.

Performing the command.

See the SS below.

<img width="185" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/24979963-4505-498d-b4ed-8e0ea879b777">

So these are all the commands/binaries of root user, when we perform them we get root privileges while performing the command. 
Now we need to check if there are any exploits to these binaries which can provide us a root user.
Check in GTFOBINS.
https://gtfobins.github.io/
Check each and every SUID bit in the GTFobins.
Note: We just need to look for the binaries that start with /usr and /bin directories. Also, ensure we're only examining the binaries with short commands like Ping, find, at, su, etc. We typically avoid long commands when doing privilege escalation. 
So at last, we found that there are exploits for the Find bit.

<img width="406" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/f5e8e462-c727-481b-8998-b844fcf66195">

Click on shell.

<img width="538" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/5db844f5-7cdc-409b-9153-8714ee8cfa96">

Performing the command: find . -exec /bin/sh \; -quit

<img width="137" alt="image" src="https://github.com/Arunashok1/Pentest---DC-1/assets/151181133/3525f404-b430-43f3-9358-3a998001196b">

Here we are the root user now.

























